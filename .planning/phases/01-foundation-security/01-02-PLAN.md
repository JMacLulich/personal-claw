---
phase: 01-foundation-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/bot.py
  - src/auth.py
autonomous: true

must_haves:
  truths:
    - "Discord bot connects and responds to messages"
    - "Bot only accepts commands from allowlisted user ID"
    - "Bot rejects all other users with clear message"
  artifacts:
    - path: "src/bot.py"
      provides: "Discord bot entry point"
      min_lines: 30
    - path: "src/auth.py"
      provides: "User allowlist enforcement"
      exports: ["check_allowlisted_user"]
  key_links:
    - from: "src/bot.py"
      to: "src/auth.check_allowlisted_user"
      via: "@bot.check decorator"
      pattern: "@bot\\.check.*check_allowlisted_user"
    - from: "src/bot.py"
      to: "src/config.load_config"
      via: "config initialization"
      pattern: "load_config\\(\\)"
---

<objective>
Create Discord bot with single-user access control enforced at bot level.

Purpose: Establishes secure Discord interface that only responds to Jason's allowlisted user ID, rejecting all other users. This is critical for Phase 1's security requirement.

Output: Working Discord bot that enforces user allowlist via global check decorator.
</objective>

<execution_context>
@/Users/jasonmaclulich/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/jasonmaclulich/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-security/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create user allowlist enforcement</name>
  <files>
    src/auth.py
  </files>
  <action>
Create `src/auth.py` with allowlist check:

Implement `check_allowlisted_user(ctx)` function:
- Takes Discord context (ctx)
- Checks if ctx.author.id matches allowlisted user ID from config
- Returns True if match, False otherwise
- Uses ctx.author.id (int), not string comparison

Why this approach:
- Global check runs before ALL commands (security by default)
- No way to bypass - every command goes through this check
- Fails closed (default deny)

Example structure:
```python
def check_allowlisted_user(ctx):
    """Global check: only allowlisted user can use bot."""
    from src.config import load_config
    config = load_config()
    
    if ctx.author.id != config.discord_allowlisted_user_id:
        # Log rejected attempt
        return False
    return True
```
  </action>
  <verify>
Run: `python -c "from src.auth import check_allowlisted_user; print('Auth module loaded')"`
  </verify>
  <done>
src/auth.py provides check_allowlisted_user function that validates user ID against config
  </done>
</task>

<task type="auto">
  <name>Create Discord bot with allowlist decorator</name>
  <files>
    src/bot.py
  </files>
  <action>
Create `src/bot.py` Discord bot:

1. Import dependencies:
   - discord (py-cord)
   - src.config.load_config
   - src.auth.check_allowlisted_user

2. Load config and create bot:
   - `bot = discord.Bot()`
   - Load config at startup

3. Register global check decorator:
   - `@bot.check` decorator above check_allowlisted_user
   - This enforces allowlist for ALL commands automatically

4. Add test command:
   - `@bot.command()` with name "ping"
   - Responds with "Pong! You're authorized."
   - This verifies allowlist works

5. Add error handler for check failures:
   - `@bot.event async def on_application_command_error(ctx, error)`
   - If CheckFailure, send DM: "Sorry, this bot is private."
   - Prevents silent failures

6. Add ready event:
   - `@bot.event async def on_ready()`
   - Print "Bot connected as {bot.user}"

7. Main block:
   - if __name__ == "__main__":
   - config = load_config()
   - bot.run(config.discord_bot_token)

Why @bot.check at bot level (not per-command):
- Security-first: impossible to forget on new commands
- Single point of enforcement
- Follows research finding: "User allowlist must be enforced via global @bot.check decorator"
  </action>
  <verify>
Run: `python -c "from src.bot import bot; print('Bot module loaded')"`
Bot module should load without errors
  </verify>
  <done>
src/bot.py creates Discord bot with global allowlist check, test ping command, and error handling for unauthorized users
  </done>
</task>

<task type="auto">
  <name>Test bot locally</name>
  <files>
    tests/__init__.py
    tests/test_auth.py
  </files>
  <action>
Create basic tests to verify allowlist logic:

1. Create `tests/` directory with `__init__.py`

2. Create `tests/test_auth.py`:
   - Test `check_allowlisted_user` with matching user ID (should return True)
   - Test with non-matching user ID (should return False)
   - Mock ctx object with author.id attribute

Why test auth separately:
- Running full Discord bot requires real token
- Auth logic is critical security boundary
- Tests verify logic without live bot connection

Note: Manual bot testing will happen in next plan after integration
  </action>
  <verify>
Run: `python -m pytest tests/test_auth.py -v`
Tests should pass (requires pytest in requirements.txt - add if missing)
  </verify>
  <done>
tests/test_auth.py verifies allowlist logic correctly accepts/rejects users
  </done>
</task>

</tasks>

<verification>
Overall checks:
- [ ] src/auth.py provides check_allowlisted_user function
- [ ] src/bot.py uses @bot.check decorator globally
- [ ] Bot has ping command for testing
- [ ] Bot handles check failures with user-friendly error
- [ ] tests/test_auth.py passes
</verification>

<success_criteria>
1. Discord bot code exists with global allowlist enforcement
2. Auth check runs before all commands (no bypass possible)
3. Error handler provides clear rejection message
4. Tests verify allowlist logic
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-02-SUMMARY.md`
</output>
